//===== sort.cpp =======================================================================================================
//
//  Author: Immanuel Haffner <haffner.immanuel@gmail.com>
//
//  Licence:
//      Copyright 2019 Immanuel Haffner
//
//      Licensed under the Apache License, Version 2.0 (the "License");
//      you may not use this file except in compliance with the License.
//      You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//      Unless required by applicable law or agreed to in writing, software
//      distributed under the License is distributed on an "AS IS" BASIS,
//      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//      See the License for the specific language governing permissions and
//      limitations under the License.
//
//  Description:
//      This file provides algorithms to sort data on disk, generated by "gensort" from the sortbenchmark.org
//      benchmarks.
//
//======================================================================================================================

#include "sort.hpp"

#include "hist.hpp"
#include "record.hpp"
#include <algorithm>
#include <array>
#include <atomic>
#include <cassert>
#include <cstdint>
#include <cstring>
#include <thread>
#include <vector>


#ifndef NDEBUG
#define VERBOSE
#endif


/** Computes the power of base b to the exponent e. */
template<typename Base, typename Exponent>
constexpr auto pow(Base b, Exponent e) -> decltype(b * e)
{
    return e ? b * pow(b, e - 1) : 1;
}

/** The number of buckets for a radix sort with a byte as digit. */
constexpr std::size_t NUM_BUCKETS = pow(2, 8lu * sizeof(decltype(record::key)::value_type));

unsigned long call_counter = 0;

/** Simple American flag sort. */
void american_flag_sort_helper(record * const first, record * const last, const unsigned digit)
{
    ++call_counter;
    /* Compute the histogram, a.k.a. bucket sizes, of the most significant byte. */
    histogram_t<unsigned, NUM_BUCKETS> hist{ {0} };
    for (auto p = first; p != last; ++p)
        ++hist[p->key[digit]];
    assert(hist.count() == last - first and "histogram has incorrect number of entries");

    /* Compute the bucket offsets.  Buckets of even index are filled from left to right, buckets of odd index are filled
     * from right to left. */
    std::array<record*, NUM_BUCKETS> buckets;
    buckets[0] = first;
    for (std::size_t i = 1; i != NUM_BUCKETS; ++i)
        buckets[i] = buckets[i - 1] + hist[i - 1]; // filled from left to right
    assert(buckets[NUM_BUCKETS - 1] + hist[NUM_BUCKETS - 1] == last and "incorrect computation of bucket location");

    /* Copy bucket locations for the runners. */
    auto runners = buckets;

    /* Distribute items to their buckets. */
    unsigned current_bucket = 0; ///< bucket id of the current source bucket
    while (not hist[current_bucket]) ++current_bucket; // find the first non-empty bucket
    for (;;) {
        using std::swap;

        auto src = runners[current_bucket]; // get source address
        const auto dst_bucket = src->key[digit]; // get destination bucket by digit
        auto dst = runners[dst_bucket]++; // get destination address

        if (src == dst) {
            /* Item is already in its destination bucket and need not be moved.  Find new source by searching for the
             * first unfinished bucket, starting with the current bucket. */
            while (runners[current_bucket] == buckets[current_bucket + 1]) {
                ++current_bucket;
                if (current_bucket == NUM_BUCKETS - 1)
                    goto loop_exit_distribution; // all buckets are finished
            }
            src = runners[current_bucket];
            continue;
        }

        swap(*src, *dst); // swap items
    }
loop_exit_distribution:

    /* Recursive descent to sort buckets. */
    const auto next_digit = digit + 1;
    if (next_digit != 10) {
        auto p = first;
        for (auto n : hist) {
            if (n > 5000)
                american_flag_sort_helper(p, p + n, next_digit);
            else
                std::sort(p, p + n);
            p += n;
        }
    }
}

/** American Flag Sort with multi-threading.  Employs a work stealing worker technique to parallelize the recursive
 * descent. */
void american_flag_sort_MT(record * const first, record * const last, const unsigned digit, const unsigned num_threads)
{
    ++call_counter;
    /* Compute the histogram, a.k.a. bucket sizes, of the most significant byte. */
    histogram_t<unsigned, NUM_BUCKETS> hist{ {0} };
    for (auto p = first; p != last; ++p)
        ++hist[p->key[digit]];
    assert(hist.count() == last - first and "histogram has incorrect number of entries");

    /* Compute the bucket offsets.  Buckets of even index are filled from left to right, buckets of odd index are filled
     * from right to left. */
    std::array<record*, NUM_BUCKETS> buckets;
    buckets[0] = first;
    for (std::size_t i = 1; i != NUM_BUCKETS; ++i)
        buckets[i] = buckets[i - 1] + hist[i - 1]; // filled from left to right
    assert(buckets[NUM_BUCKETS - 1] + hist[NUM_BUCKETS - 1] == last and "incorrect computation of bucket location");

    /* Copy bucket locations for the runners. */
    auto runners = buckets;

    /* Distribute items to their buckets. */
    unsigned current_bucket = 0; ///< bucket id of the current source bucket
    while (not hist[current_bucket]) ++current_bucket; // find the first non-empty bucket
    for (;;) {
        using std::swap;

        auto src = runners[current_bucket]; // get source address
        const auto dst_bucket = src->key[digit]; // get destination bucket by digit
        auto dst = runners[dst_bucket]++; // get destination address

        if (src == dst) {
            /* Item is already in its destination bucket and need not be moved.  Find new source by searching for the
             * first unfinished bucket, starting with the current bucket. */
            while (runners[current_bucket] == buckets[current_bucket + 1]) {
                ++current_bucket;
                if (current_bucket == NUM_BUCKETS - 1)
                    goto loop_exit_distribution; // all buckets are finished
            }
            src = runners[current_bucket];
            continue;
        }

        swap(*src, *dst); // swap items
    }
loop_exit_distribution:

    /* Recursively sort the buckets.  Use a thread pool of worker threads and let the workers claim buckets for
     * sorting from a queue. */
    const auto next_digit = digit + 1; ///< next digit to sort by
    if (next_digit != 10) {
        std::atomic_uint_fast32_t bucket_counter(0);
        auto recurse = [&](unsigned tid) {
            uint_fast32_t bucket_id;
            while ((bucket_id = bucket_counter.fetch_add(1)) < NUM_BUCKETS) {
                const auto num_records = hist[bucket_id];
                if (num_records <= 1) continue;

                std::ostringstream oss;
                oss << "Thread " << tid << " sorts bucket " << bucket_id << " with " << num_records << " records.\n";
                std::cerr << oss.str();

                auto thread_first = buckets[bucket_id];
                auto thread_last = thread_first + num_records;
                assert(first <= thread_first);
                assert(thread_last <= last);
                assert(thread_first <= thread_last);
                if (hist[bucket_id] > 5000)
                    american_flag_sort_helper(thread_first, thread_last, next_digit);
                else
                    std::sort(thread_first, thread_last);
            }
        };

        auto threads = new std::thread[num_threads];
        for (unsigned tid = 0; tid != num_threads; ++tid)
            threads[tid] = std::thread(recurse, tid);
        for (unsigned tid = 0; tid != num_threads; ++tid) {
            if (threads[tid].joinable())
                threads[tid].join();
        }
    }
}

void american_flag_sort(record *first, record *last) {
    call_counter = 0;
    american_flag_sort_MT(first, last, 0, 16);
    std::cerr << "Performed " << call_counter << " recursive calls for " << (last - first) << " elements.\n";
}
