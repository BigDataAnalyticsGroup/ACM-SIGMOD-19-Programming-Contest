//===== sort.cpp =======================================================================================================
//
//  Author: Immanuel Haffner <haffner.immanuel@gmail.com>
//
//  Licence:
//      Copyright 2019 Immanuel Haffner
//
//      Licensed under the Apache License, Version 2.0 (the "License");
//      you may not use this file except in compliance with the License.
//      You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//      Unless required by applicable law or agreed to in writing, software
//      distributed under the License is distributed on an "AS IS" BASIS,
//      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//      See the License for the specific language governing permissions and
//      limitations under the License.
//
//  Description:
//      This file provides algorithms to sort data on disk, generated by "gensort" from the sortbenchmark.org
//      benchmarks.
//
//======================================================================================================================

#include "sort.hpp"

#include "mmap.hpp"
#include "record.hpp"
#include <algorithm>
#include <array>
#include <cassert>
#include <cstdint>
#include <cstring>
#include <err.h>
#include <fstream>
#include <vector>


void example_sort(const char *infile, const char *outfile)
{
    constexpr int kTupleSize = 100;
    constexpr int kKeySize = 10;
    using tuple_t = std::array<unsigned char, kTupleSize>;

    auto less = [](const tuple_t &lhs, const tuple_t &rhs) {
        for (int i = 0; i < kKeySize; ++i) {
            if (lhs[i] == rhs[i])
                continue;
            return lhs[i] < rhs[i];
        }
        return false;
    };

    std::ifstream is(infile);
    if (!is) {
        std::cerr << "Could not open the file\n";
        std::exit(-1);
    }

    // get size of file
    is.seekg(0, is.end);
    const std::int64_t size = is.tellg();
    is.seekg(0);

    // allocate memory for file content
    const std::int64_t num_tuples = size / kTupleSize;
    std::vector<tuple_t> buffer(num_tuples);

    std::ofstream os(outfile);

    // read content of is
    for (std::int64_t i = 0; i < num_tuples; ++i)
        is.read(reinterpret_cast<char*>(buffer[i].data()), kTupleSize);

    std::stable_sort(buffer.begin(), buffer.end(), less);

    for (std::int64_t i = 0; i < num_tuples; ++i)
        os.write(reinterpret_cast<char*>(buffer[i].data()), kTupleSize);

    assert(std::is_sorted(buffer.begin(), buffer.end(), less));

    os.flush();
    is.close();
    os.close();
}

void stl_sort_mmap_direct(const char *infile, const char *outfile)
{
    MMapFile in(infile, O_RDONLY, true);

    /* Access the data as array of struct. */
    auto data = reinterpret_cast<record*>(in.addr());
    const std::size_t count = in.size() / sizeof(*data);

    /* Sort all records. */
    std::sort(data, data + count, [](const record &first, const record &second) {
            return memcmp(first.key, second.key, 10) < 0;
            });

    /* Write the sorted data. */
    int fildes_out = open(outfile, O_WRONLY);
    if (-1 == fildes_out)
        err(EXIT_FAILURE, "Could not open file '%s'", outfile);
    write(fildes_out, in.addr(), in.size());
    fsync(fildes_out);
    if (close(fildes_out))
        warn("Failed to close file '%s'", outfile);
}

void stl_sort_mmap_file(const char *infile, const char *outfile)
{
    MMapFile in(infile, O_RDONLY, true);

    /* Access the data as array of struct. */
    auto data = reinterpret_cast<record*>(in.addr());
    const std::size_t count = in.size() / sizeof(*data);

    /* Sort all records. */
    std::sort(data, data + count, [](const record &first, const record &second) {
            return memcmp(first.key, second.key, 10) < 0;
            });

    /* Write the sorted data. */
    FILE *out = fopen(outfile, "w");
    if (not out)
        err(EXIT_FAILURE, "Could not open file '%s'", outfile);
    fwrite(in.addr(), 1, in.size(), out);
    fflush(out);
    if (fclose(out))
        warn("Failed to close file '%s'", outfile);
}

void stl_sort_mmap_stream(const char *infile, const char *outfile)
{
    MMapFile in(infile, O_RDONLY, true);

    /* Access the data as array of struct. */
    auto data = reinterpret_cast<record*>(in.addr());
    const std::size_t count = in.size() / sizeof(*data);

    /* Sort all records. */
    std::sort(data, data + count, [](const record &first, const record &second) {
            return memcmp(first.key, second.key, 10) < 0;
            });

    /* Write the sorted data. */
    std::ofstream out(outfile);
    out.write(reinterpret_cast<char*>(in.addr()), in.size());
    out.flush();
}

void stl_sort_mmap_file_custom_buffer(const char *infile, const char *outfile)
{
    MMapFile in(infile, O_RDONLY, true);

    /* Access the data as array of struct. */
    auto data = reinterpret_cast<record*>(in.addr());
    const std::size_t count = in.size() / sizeof(*data);

    /* Sort all records. */
    std::sort(data, data + count, [](const record &first, const record &second) {
            return memcmp(first.key, second.key, 10) < 0;
            });

    /* Write the sorted data. */
    constexpr std::size_t BUFFER_SIZE = 32 * 1024 * 1024; // 32 MiB
    FILE *out = fopen(outfile, "w");
    char *buf = static_cast<char*>(malloc(BUFFER_SIZE));
    setvbuf(out, buf, /* mode = */ _IOFBF, BUFFER_SIZE);
    if (not out)
        err(EXIT_FAILURE, "Could not open file '%s'", outfile);
    fwrite(in.addr(), 1, in.size(), out);
    fflush(out);
    if (fclose(out))
        warn("Failed to close file '%s'", outfile);
    free(buf);
}

void stl_sort_mmap_stream_custom_buffer(const char *infile, const char *outfile)
{
    MMapFile in(infile, O_RDONLY, true);

    /* Access the data as array of struct. */
    auto data = reinterpret_cast<record*>(in.addr());
    const std::size_t count = in.size() / sizeof(*data);

    /* Sort all records. */
    std::sort(data, data + count, [](const record &first, const record &second) {
            return memcmp(first.key, second.key, 10) < 0;
            });

    /* Write the sorted data. */
    constexpr std::size_t BUFFER_SIZE = 32 * 1024 * 1024; // 32 MiB
    char *buf = static_cast<char*>(malloc(BUFFER_SIZE));
    std::ofstream out;
    out.rdbuf()->pubsetbuf(buf, BUFFER_SIZE);
    out.open(outfile);
    out.write(reinterpret_cast<char*>(in.addr()), in.size());
    out.flush();
    free(buf);
}
