//===== radix_partition.cpp ============================================================================================
//
//  Author: Immanuel Haffner <haffner.immanuel@gmail.com>
//
//  Licence:
//      Copyright 2019 Immanuel Haffner
//
//      Licensed under the Apache License, Version 2.0 (the "License");
//      you may not use this file except in compliance with the License.
//      You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//      Unless required by applicable law or agreed to in writing, software
//      distributed under the License is distributed on an "AS IS" BASIS,
//      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//      See the License for the specific language governing permissions and
//      limitations under the License.
//
//  Description:
//      This file provides algorithms to radix partition data on disk, generated by "gensort" from the sortbenchmark.org
//      benchmarks.
//
//======================================================================================================================

#include "radix_partition.hpp"

#include "record.hpp"
#include <array>
#include <cassert>
#include <cstdint>
#include <cstdio>
#include <cstring>
#include <err.h>
#include <fcntl.h>
#include <fstream>
#include <iostream>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <vector>


void partition_hist_mmap(const char *infile, const char *outfile, const histogram_t &histogram)
{
    /* Open the input file. */
    FILE *in = fopen(infile, "rb");
    if (not in)
        err(EXIT_FAILURE, "Could not open file '%s'", infile);
    const int fildes_in = fileno(in);

    /* Retrieve file size in bytes. */
    struct stat stat_in;
    if (fstat(fildes_in, &stat_in))
        err(EXIT_FAILURE, "Could not stat file '%s'", infile);
    const auto size_in_bytes = stat_in.st_size;

    /* Allocate output file. */
    const int fildes_out = open(outfile, O_CREAT|O_TRUNC|O_RDWR, /* mode = */ 0644); // rw-r--r--
    if (fildes_out == -1)
        err(EXIT_FAILURE, "Could not create output file '%s'", outfile);
    if (ftruncate(fildes_out, size_in_bytes))
        err(EXIT_FAILURE, "Could not truncate file '%s'", outfile);

    /* mmap the output file. */
    void * const out = mmap(nullptr, size_in_bytes, PROT_READ|PROT_WRITE, MAP_PRIVATE, fildes_out, 0);
    if (MAP_FAILED == out)
        err(EXIT_FAILURE, "Could not mmap() file '%s'", outfile);

    /* Compute the number of records. */
    const unsigned num_records = size_in_bytes / sizeof(record);

    /* Compute the partition locations. */
    std::array<uint8_t*, NUM_PARTITIONS> partitions;
    unsigned offset = 0;
    for (std::size_t i = 0; i != NUM_PARTITIONS; ++i) {
        partitions[i] = static_cast<uint8_t*>(out) + offset * sizeof(record);
        offset += histogram[i];
    }
    assert(offset == num_records);

    /* Sequentially scan the input data and write it to its respective partitions. */
    rewind(in); // go back to the start
    for (unsigned i = 0; i != num_records; ++i) {
        const uint8_t k0 = getc_unlocked(in);
        uint8_t *p = partitions[k0];
        p[0] = k0;
        fread(p + 1, /* size = */ 1, /* nmemb = */ 99, in);
        p += 100;
    }

    /* Close acquired resources. */
    msync(out, size_in_bytes, MS_ASYNC);
    munmap(out, size_in_bytes);
    fclose(in);
    close(fildes_out);
}
