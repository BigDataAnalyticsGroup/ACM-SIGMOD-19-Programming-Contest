//===== radix_partition.cpp ============================================================================================
//
//  Author: Immanuel Haffner <haffner.immanuel@gmail.com>
//
//  Licence:
//      Copyright 2019 Immanuel Haffner
//
//      Licensed under the Apache License, Version 2.0 (the "License");
//      you may not use this file except in compliance with the License.
//      You may obtain a copy of the License at
//
//        http://www.apache.org/licenses/LICENSE-2.0
//
//      Unless required by applicable law or agreed to in writing, software
//      distributed under the License is distributed on an "AS IS" BASIS,
//      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//      See the License for the specific language governing permissions and
//      limitations under the License.
//
//  Description:
//      This file provides algorithms to radix partition data on disk, generated by "gensort" from the sortbenchmark.org
//      benchmarks.
//
//======================================================================================================================

#include "radix_partition.hpp"

#include "constants.hpp"
#include "record.hpp"
#include <array>
#include <cassert>
#include <cstdint>
#include <cstdio>
#include <cstring>
#include <err.h>
#include <fcntl.h>
#include <fstream>
#include <iostream>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <vector>


void example_partition(const char *infile, const char *outfile)
{
    constexpr int kTupleSize = 100;
    constexpr std::uint16_t kNumPartitionBits = 10;
    constexpr std::uint16_t kShift = kNumPartitionBits - sizeof(char) * 8; // 10 - 1 * 8 = 2
    constexpr std::uint16_t kLowMask = (1u << kShift) - 1u; // 0b11
    constexpr std::uint16_t kMask = (1u << kNumPartitionBits) - 1u; // 0b1111111111

    auto getPartitionId = [](const char *key) {
        std::uint16_t pid = (*key) << kShift;
        pid += *(key + 1) & kLowMask;
        pid &= kMask;
        return pid;
    };

    std::ifstream is(infile);
    if (!is) {
        std::cerr << "Could not open the file\n";
        std::exit(-1);
    }

    // get size of file
    is.seekg(0, is.end);
    const std::int64_t size = is.tellg();
    is.seekg(0);

    const std::int64_t num_tuples = size / kTupleSize;

    const std::uint16_t kNumPartitions = 1 << kNumPartitionBits;
    std::vector<int> histogram(kNumPartitions);
    char buffer[kTupleSize];

    // read content of is
    for (std::int64_t i = 0; i < num_tuples; ++i) {
        is.read(buffer, kTupleSize);
        const std::uint16_t p = getPartitionId(buffer);
        ++histogram[p];
    }

    std::vector<int> offset(kNumPartitions);
    int count = histogram[0];
    for (std::uint16_t p = 1; p < kNumPartitions; ++p) {
        offset[p] = count;
        count += histogram[p];
    }

    std::vector<char> output(size);

    // read content of is
    is.seekg(0);
    for (std::int64_t i = 0; i < num_tuples; ++i) {
        is.read(buffer, kTupleSize);
        const std::uint16_t p = getPartitionId(buffer);
        const std::uint64_t dest = offset[p]++;
        std::memcpy(&output[dest * kTupleSize], buffer, kTupleSize);
    }
    is.close();

    std::ofstream os(outfile);
    os.write(output.data(), size);
    os.close();
}

void partition_hist_mmap(const char *infile, const char *outfile)
{
    /* Open the input file. */
    FILE *in = fopen(infile, "rb");
    if (not in)
        err(EXIT_FAILURE, "Could not open file '%s'", infile);
    const int fildes_in = fileno(in);

    /* Retrieve file size in bytes. */
    struct stat stat_in;
    if (fstat(fildes_in, &stat_in))
        err(EXIT_FAILURE, "Could not stat file '%s'", infile);
    const auto size_in_bytes = stat_in.st_size;

    /* Allocate output file. */
    //const int fildes_out = creat(outfile, [> mode = <] 0644); // rw-r--r--
    const int fildes_out = open(outfile, O_CREAT|O_TRUNC|O_RDWR, /* mode = */ 0644); // rw-r--r--
    if (fildes_out == -1)
        err(EXIT_FAILURE, "Could not create output file '%s'", outfile);
    if (ftruncate(fildes_out, size_in_bytes))
        err(EXIT_FAILURE, "Could not truncate file '%s'", outfile);

    /* mmap the output file. */
    void * const out = mmap(nullptr, size_in_bytes, PROT_READ|PROT_WRITE, MAP_PRIVATE, fildes_out, 0);
    if (MAP_FAILED == out)
        err(EXIT_FAILURE, "Could not mmap() file '%s'", outfile);

    /* Compute the number of records. */
    const unsigned num_records = size_in_bytes / sizeof(record);

    /* Compute the histogram. */
    std::array<unsigned, 1024> histogram{ 0 };
    for (unsigned i = 0; i != num_records; ++i) {
        const uint32_t k0 = getc_unlocked(in);
        const uint32_t k1 = getc_unlocked(in);
        const uint32_t pid = (k0 << 2) | (k1 >> 6);
        for (unsigned i = 2; i != sizeof(record); ++i)
            getc_unlocked(in);
        assert(pid < 1024);
        ++histogram[pid];
    }

    /* Compute the partition locations. */
    std::array<uint8_t*, 1024> partitions;
    unsigned offset = 0;
    for (std::size_t i = 0; i != 1024; ++i) {
        partitions[i] = static_cast<uint8_t*>(out) + offset * sizeof(record);
        offset += histogram[i];
    }
    assert(offset == num_records);

    /* Sequentially scan the input data and write it to its respective partitions. */
    rewind(in); // go back to the start
    for (unsigned i = 0; i != num_records; ++i) {
        const uint8_t k0 = getc_unlocked(in);
        const uint8_t k1 = getc_unlocked(in);
        const uint32_t pid = (k0 << 2) | (k1 >> 6);
        uint8_t *p = partitions[pid];
        p[0] = k0;
        p[1] = k1;
        fread(p + 2, /* size = */ 1, /* nmemb = */ 98, in);
        p += 100;
    }

    /* Close acquired resources. */
    msync(out, size_in_bytes, MS_ASYNC);
    munmap(out, size_in_bytes);
    fclose(in);
    close(fildes_out);
}
